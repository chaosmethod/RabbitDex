<script>
// Capture helper: returns base64 (without data: prefix) or throws
async function captureImageBase64() {
  if (!cameraStream) {
    await startCamera();
    if (!cameraStream) throw new Error('Camera not available');
  }
  if (!videoEl || videoEl.readyState < 2) throw new Error('Camera not ready');
  const canvas = document.createElement('canvas');
  canvas.width = 240;
  canvas.height = 282;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(videoEl, 0, 0, canvas.width, canvas.height);
  const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
  return dataUrl.split(',')[1];
}

// Parse LLM reply to a single name string (be lenient)
function normalizeLLMName(resp) {
  if (!resp) return null;
  // If resp is object with name property
  if (typeof resp === 'object') {
    if (resp.name && typeof resp.name === 'string') return resp.name.trim();
    // maybe platform returned { message: '{"name":"Pikachu"}' }
    if (resp.message && typeof resp.message === 'string') {
      try {
        const inner = JSON.parse(resp.message);
        if (inner && inner.name) return inner.name.trim();
      } catch(e){}
      // or message could be plain text name
      return resp.message.trim();
    }
  }
  // If resp is string, choose first token or full line
  if (typeof resp === 'string') {
    // remove punctuation and guidance words
    let s = resp.trim();
    // Some LLMs reply with "Pikachu." or "The pokemon is Pikachu"
    s = s.replace(/^the\s+pokemon\s+is\s+/i, '');
    s = s.replace(/[^\w\s-']/g, ''); // strip punctuation
    // prefer single line, return first line
    s = s.split('\n')[0].trim();
    return s || null;
  }
  return null;
}

// High-level PTT scan handler
async function pttScanHandler() {
  try {
    log('PTT pressed: capturing image');
    const imageBase64 = await captureImageBase64();
    const prompt = 'what is this pokemon in a name only reply';
    log('Sending to LLM with prompt: "' + prompt + '"');
    // sendToLLM is the robust wrapper; increase timeout to 20s
    const llmResp = await sendToLLM({ llm: prompt, imageBase64 }, { timeout: 20000 }).catch(err => { throw err; });
    log('[LLM] raw response: ' + (typeof llmResp === 'string' ? llmResp.slice(0,200) : JSON.stringify(llmResp).slice(0,200)));
    const detectedName = normalizeLLMName(llmResp);
    if (!detectedName) {
      log('LLM did not return a usable name');
      return;
    }
    log('Detected name: ' + detectedName);
    // Search pokedex index for URL
    const url = await findPokedexUrlByName(detectedName);
    if (url) log('Found pokedex url: ' + url);
    else log('Pokedex URL not found for: ' + detectedName);
    // Build entry and save
    const entry = {
      name: detectedName,
      type: '', // LLM prompt asked for name-only; could do another call if needed
      description: '',
      pokedexUrl: url || '',
      capturedAt: new Date().toISOString()
    };
    saveEntry(entry);
    updateGallery();
    switchView('rabbitdex');
    showDetail( (storageGet('rabbitdex') || []).length - 1 );
  } catch (e) {
    log('PTT scan error: ' + (e && e.message ? e.message : e));
  }
}

// Bind PTT/hardware sideClick event to the handler
window.addEventListener('sideClick', () => {
  // Debounce briefly to avoid duplicate triggers
  if (window._pttBusy) return;
  window._pttBusy = true;
  pttScanHandler().finally(() => {
    // small cooldown
    setTimeout(() => { window._pttBusy = false; }, 700);
  });
});

// Optionally bind longPressStart to narrate if pressed while in rabbitdex
// (keep existing longPressStart behavior, don't override)
</script>
